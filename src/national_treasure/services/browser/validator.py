"""Response validation for bot detection (OPT-122)."""

from dataclasses import dataclass

from playwright.async_api import Page, Response

from national_treasure.core.models import BlockedBy, ValidationResult


@dataclass
class BlockPattern:
    """Pattern for detecting blocked pages."""

    service: BlockedBy
    patterns: list[str]
    case_sensitive: bool = False


# Block detection patterns
BLOCK_PATTERNS = [
    BlockPattern(
        service=BlockedBy.CLOUDFRONT,
        patterns=[
            "generated by cloudfront",
            "request could not be satisfied",
            "error: the request could not be satisfied",
            "cloudfront distribution",
        ],
    ),
    BlockPattern(
        service=BlockedBy.CLOUDFLARE,
        patterns=[
            "just a moment",
            "checking your browser",
            "ray id:",
            "cf-ray",
            "cloudflare",
            "attention required!",
            "please wait while we check your browser",
        ],
    ),
    BlockPattern(
        service=BlockedBy.AKAMAI,
        patterns=[
            "access denied",
            "akamai",
            "ghost_url",
        ],
    ),
    BlockPattern(
        service=BlockedBy.IMPERVA,
        patterns=[
            "incapsula",
            "imperva",
            "_incap_",
        ],
    ),
    BlockPattern(
        service=BlockedBy.DATADOME,
        patterns=[
            "datadome",
            "dd_",
        ],
    ),
    BlockPattern(
        service=BlockedBy.PERIMETERX,
        patterns=[
            "perimeterx",
            "_px",
            "px-captcha",
        ],
    ),
]

# CAPTCHA patterns
CAPTCHA_PATTERNS = [
    "recaptcha",
    "hcaptcha",
    "captcha-container",
    "g-recaptcha",
    "cf-turnstile",
    "challenge-form",
    "challenge-running",
    "captcha_",
]

# Rate limit patterns
RATE_LIMIT_PATTERNS = [
    "too many requests",
    "rate limit exceeded",
    "please slow down",
    "you have been rate limited",
    "access temporarily blocked",
]

# Login wall patterns
LOGIN_WALL_PATTERNS = [
    "please log in",
    "please sign in",
    "login required",
    "sign in to continue",
    "create an account",
    "you must be logged in",
]


class ResponseValidator:
    """Validate responses for bot detection and errors."""

    def __init__(
        self,
        min_content_length: int = 500,
        custom_block_patterns: list[str] | None = None,
        custom_success_patterns: list[str] | None = None,
    ):
        """Initialize validator.

        Args:
            min_content_length: Minimum content length to consider valid
            custom_block_patterns: Additional patterns to detect blocks
            custom_success_patterns: Patterns that indicate success
        """
        self.min_content_length = min_content_length
        self.custom_block_patterns = custom_block_patterns or []
        self.custom_success_patterns = custom_success_patterns or []

    async def validate(
        self,
        response: Response | None,
        page: Page,
    ) -> ValidationResult:
        """Validate a page response.

        Args:
            response: Playwright response object
            page: Playwright page object

        Returns:
            ValidationResult with blocked status and details
        """
        # Check for navigation failure
        if response is None:
            return ValidationResult(
                blocked=True,
                reason="navigation_failed",
                details="No response received",
            )

        # Check HTTP status
        status = response.status
        if status >= 400:
            blocked_by = self._detect_service_from_status(status, response)
            return ValidationResult(
                blocked=True,
                reason=f"http_{status}",
                http_status=status,
                blocked_by=blocked_by,
            )

        # Get page content for pattern matching
        try:
            content = await page.content()
        except Exception as e:
            return ValidationResult(
                blocked=True,
                reason="content_error",
                details=str(e),
            )

        content_lower = content.lower()

        # Check for success patterns first
        for pattern in self.custom_success_patterns:
            if pattern.lower() in content_lower:
                return ValidationResult(blocked=False)

        # Check for block patterns
        for block_pattern in BLOCK_PATTERNS:
            for pattern in block_pattern.patterns:
                check_content = content if block_pattern.case_sensitive else content_lower
                check_pattern = pattern if block_pattern.case_sensitive else pattern.lower()
                if check_pattern in check_content:
                    return ValidationResult(
                        blocked=True,
                        reason=block_pattern.service.value,
                        pattern=pattern,
                        http_status=status,
                    )

        # Check custom block patterns
        for pattern in self.custom_block_patterns:
            if pattern.lower() in content_lower:
                return ValidationResult(
                    blocked=True,
                    reason="custom_block",
                    pattern=pattern,
                    http_status=status,
                )

        # Check for CAPTCHA
        for pattern in CAPTCHA_PATTERNS:
            if pattern.lower() in content_lower:
                return ValidationResult(
                    blocked=True,
                    reason="captcha",
                    pattern=pattern,
                    http_status=status,
                )

        # Check for rate limiting
        for pattern in RATE_LIMIT_PATTERNS:
            if pattern.lower() in content_lower:
                return ValidationResult(
                    blocked=True,
                    reason="rate_limited",
                    pattern=pattern,
                    http_status=status,
                )

        # Check for suspiciously short content
        text_content = await self._extract_text_content(page)
        if len(text_content.strip()) < self.min_content_length:
            # Check if it's a redirect page or simple page
            if not self._is_expected_short_page(content_lower):
                return ValidationResult(
                    blocked=True,
                    reason="content_too_short",
                    details=f"{len(text_content)} chars (min: {self.min_content_length})",
                    http_status=status,
                )

        # Check for login wall
        for pattern in LOGIN_WALL_PATTERNS:
            if pattern.lower() in content_lower:
                return ValidationResult(
                    blocked=False,  # Not blocked, but limited
                    reason="login_required",
                    pattern=pattern,
                    http_status=status,
                )

        return ValidationResult(blocked=False, http_status=status)

    async def _extract_text_content(self, page: Page) -> str:
        """Extract visible text content from page."""
        try:
            return await page.evaluate("""
                () => {
                    const body = document.body;
                    if (!body) return '';
                    return body.innerText || body.textContent || '';
                }
            """)
        except Exception:
            return ""

    def _detect_service_from_status(
        self,
        status: int,
        response: Response,
    ) -> str | None:
        """Detect blocking service from status code and headers."""
        headers = response.headers

        # Check for Cloudflare
        if "cf-ray" in headers or "cf-cache-status" in headers:
            return BlockedBy.CLOUDFLARE.value

        # Check for CloudFront
        if "x-amz-cf-id" in headers or "x-amz-cf-pop" in headers:
            return BlockedBy.CLOUDFRONT.value

        # Check for Akamai
        if "x-akamai-request-id" in headers:
            return BlockedBy.AKAMAI.value

        return None

    def _is_expected_short_page(self, content: str) -> bool:
        """Check if short content is expected (e.g., API response, redirect)."""
        # JSON response
        if content.strip().startswith("{") or content.strip().startswith("["):
            return True

        # Meta refresh redirect
        if "http-equiv" in content and "refresh" in content:
            return True

        # Empty body with just head
        return "<body>" in content and content.count("<") < 20


async def validate_response(
    response: Response | None,
    page: Page,
    min_content_length: int = 500,
) -> ValidationResult:
    """Convenience function to validate a response.

    Args:
        response: Playwright response object
        page: Playwright page object
        min_content_length: Minimum content length

    Returns:
        ValidationResult
    """
    validator = ResponseValidator(min_content_length=min_content_length)
    return await validator.validate(response, page)
